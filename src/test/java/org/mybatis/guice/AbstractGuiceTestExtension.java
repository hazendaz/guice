/*
 *    Copyright 2009-2022 the original author or authors.
 *
 *    Licensed under the Apache License, Version 2.0 (the "License");
 *    you may not use this file except in compliance with the License.
 *    You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 *    Unless required by applicable law or agreed to in writing, software
 *    distributed under the License is distributed on an "AS IS" BASIS,
 *    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *    See the License for the specific language governing permissions and
 *    limitations under the License.
 */
package org.mybatis.guice;

import static java.lang.System.currentTimeMillis;

import static com.google.inject.Guice.createInjector;
import static com.google.inject.name.Names.bindProperties;
import static com.google.inject.name.Names.named;

import com.google.inject.Binder;
import com.google.inject.Injector;
import com.google.inject.Module;

import java.io.StringReader;
import java.sql.SQLException;
import java.util.List;
import java.util.Properties;

import javax.sql.DataSource;

import org.apache.ibatis.jdbc.ScriptRunner;
import org.apache.ibatis.mapping.Environment;
import org.apache.ibatis.session.SqlSessionFactory;
import org.junit.jupiter.api.extension.AfterEachCallback;
import org.junit.jupiter.api.extension.BeforeEachCallback;
import org.junit.jupiter.api.extension.ExtensionContext;
import org.junit.jupiter.api.extension.TestInstanceFactory;
import org.junit.jupiter.api.extension.TestInstanceFactoryContext;
import org.junit.jupiter.api.extension.TestInstantiationException;

abstract class AbstractGuiceTestExtension implements AfterEachCallback, BeforeEachCallback, TestInstanceFactory {

  private final Injector injector;

  public AbstractGuiceTestExtension() throws SQLException {
    final Contact contact = new Contact();
    contact.setFirstName("John");
    contact.setLastName("Doe");
    contact.setCreated(new CustomType(currentTimeMillis()));
    contact.setAddress(null);

    final Contact contactWithAddress = new Contact();
    contactWithAddress.setFirstName("John");
    contactWithAddress.setLastName("Doe");
    contactWithAddress.setCreated(new CustomType(currentTimeMillis()));

    final Address address = new Address();
    address.setNumber(1234);
    address.setStreet("Elm street");
    contactWithAddress.setAddress(address);

    final Counter counter = new Counter();

    // bindings
    final List<Module> modules = this.createMyBatisModule();
    modules.add(new Module() {
      @Override
      public void configure(Binder binder) {
        bindProperties(binder, createTestProperties());
        binder.bind(Contact.class).toInstance(contact);
        binder.bind(Contact.class).annotatedWith(named("contactWithAddress")).toInstance(contactWithAddress);
        binder.bind(Counter.class).toInstance(counter);
      }
    });
    this.injector = createInjector(modules);

    // prepare the test db
    final Environment environment = this.injector.getInstance(SqlSessionFactory.class).getConfiguration()
        .getEnvironment();
    final DataSource dataSource = environment.getDataSource();
    final ScriptRunner runner = new ScriptRunner(dataSource.getConnection());
    runner.setAutoCommit(true);
    runner.setStopOnError(true);
    runner.runScript(new StringReader("DROP TABLE IF EXISTS contact;"
        + "CREATE TABLE contact (id int GENERATED BY DEFAULT AS IDENTITY (START WITH 1), "
        + "first_name VARCHAR(20) NOT NULL, " + "last_name VARCHAR(20) NOT NULL, " + "created TIMESTAMP, "
        + "address VARCHAR(100) DEFAULT NULL) ;"));
    dataSource.getConnection().close();
  }

  protected abstract List<Module> createMyBatisModule();

  protected abstract Properties createTestProperties();

  @Override
  public Object createTestInstance(TestInstanceFactoryContext factoryContext, ExtensionContext extensionContext)
      throws TestInstantiationException {
    return this.injector.getInstance(factoryContext.getTestClass());
  }

  @Override
  public void afterEach(ExtensionContext context) throws Exception {
    CleanDatabaseRule extension = injector.getInstance(CleanDatabaseRule.class);
    extension.evaluate();
  }

  @Override
  public void beforeEach(ExtensionContext context) throws Exception {
    CleanDatabaseRule extension = injector.getInstance(CleanDatabaseRule.class);
    extension.evaluate();
  }

}
